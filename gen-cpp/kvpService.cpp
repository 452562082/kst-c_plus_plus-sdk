/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "kvpService.h"




kvpService_kvpPing_args::~kvpService_kvpPing_args() throw() {
}


uint32_t kvpService_kvpPing_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpPing_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpPing_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpPing_pargs::~kvpService_kvpPing_pargs() throw() {
}


uint32_t kvpService_kvpPing_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpPing_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpPing_result::~kvpService_kvpPing_result() throw() {
}


uint32_t kvpService_kvpPing_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpPing_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpPing_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpPing_presult::~kvpService_kvpPing_presult() throw() {
}


uint32_t kvpService_kvpPing_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpGetUttInfo_args::~kvpService_kvpGetUttInfo_args() throw() {
}


uint32_t kvpService_kvpGetUttInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->wavpath);
          this->__isset.wavpath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpGetUttInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpGetUttInfo_args");

  xfer += oprot->writeFieldBegin("wavpath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->wavpath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpGetUttInfo_pargs::~kvpService_kvpGetUttInfo_pargs() throw() {
}


uint32_t kvpService_kvpGetUttInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpGetUttInfo_pargs");

  xfer += oprot->writeFieldBegin("wavpath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->wavpath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpGetUttInfo_result::~kvpService_kvpGetUttInfo_result() throw() {
}


uint32_t kvpService_kvpGetUttInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpGetUttInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpGetUttInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpGetUttInfo_presult::~kvpService_kvpGetUttInfo_presult() throw() {
}


uint32_t kvpService_kvpGetUttInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpModelRemoveBySpkid_args::~kvpService_kvpModelRemoveBySpkid_args() throw() {
}


uint32_t kvpService_kvpModelRemoveBySpkid_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_dir);
          this->__isset.vp_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->spk_id);
          this->__isset.spk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpModelRemoveBySpkid_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpModelRemoveBySpkid_args");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_dir", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vp_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->spk_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpModelRemoveBySpkid_pargs::~kvpService_kvpModelRemoveBySpkid_pargs() throw() {
}


uint32_t kvpService_kvpModelRemoveBySpkid_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpModelRemoveBySpkid_pargs");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_dir", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->vp_dir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->spk_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpModelRemoveBySpkid_result::~kvpService_kvpModelRemoveBySpkid_result() throw() {
}


uint32_t kvpService_kvpModelRemoveBySpkid_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpModelRemoveBySpkid_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpModelRemoveBySpkid_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpModelRemoveBySpkid_presult::~kvpService_kvpModelRemoveBySpkid_presult() throw() {
}


uint32_t kvpService_kvpModelRemoveBySpkid_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpRegisterSpeakerByFile_args::~kvpService_kvpRegisterSpeakerByFile_args() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByFile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->utt);
          this->__isset.utt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_dir);
          this->__isset.vp_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->spk_id);
          this->__isset.spk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sp_chan);
          this->__isset.sp_chan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpRegisterSpeakerByFile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpRegisterSpeakerByFile_args");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->utt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_dir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->vp_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->spk_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sp_chan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpRegisterSpeakerByFile_pargs::~kvpService_kvpRegisterSpeakerByFile_pargs() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByFile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpRegisterSpeakerByFile_pargs");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->utt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_dir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->vp_dir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->spk_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->sp_chan)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpRegisterSpeakerByFile_result::~kvpService_kvpRegisterSpeakerByFile_result() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByFile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpRegisterSpeakerByFile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpRegisterSpeakerByFile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpRegisterSpeakerByFile_presult::~kvpService_kvpRegisterSpeakerByFile_presult() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByFile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpVerifySpeakerByFile_args::~kvpService_kvpVerifySpeakerByFile_args() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByFile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->utt);
          this->__isset.utt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->spk_id);
          this->__isset.spk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type);
          this->__isset.utt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sp_chan);
          this->__isset.sp_chan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpVerifySpeakerByFile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpVerifySpeakerByFile_args");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->utt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->spk_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->utt_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sp_chan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpVerifySpeakerByFile_pargs::~kvpService_kvpVerifySpeakerByFile_pargs() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByFile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpVerifySpeakerByFile_pargs");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->utt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->spk_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->utt_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->sp_chan)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpVerifySpeakerByFile_result::~kvpService_kvpVerifySpeakerByFile_result() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByFile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpVerifySpeakerByFile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpVerifySpeakerByFile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpVerifySpeakerByFile_presult::~kvpService_kvpVerifySpeakerByFile_presult() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByFile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpTempVerifySpeakerByFile_args::~kvpService_kvpTempVerifySpeakerByFile_args() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByFile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->utt1);
          this->__isset.utt1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sp_chan1);
          this->__isset.sp_chan1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type1);
          this->__isset.utt_type1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->utt2);
          this->__isset.utt2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sp_chan2);
          this->__isset.sp_chan2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type2);
          this->__isset.utt_type2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpTempVerifySpeakerByFile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpTempVerifySpeakerByFile_args");

  xfer += oprot->writeFieldBegin("utt1", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->utt1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->sp_chan1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type1", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->utt_type1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->utt2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan2", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sp_chan2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type2", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->utt_type2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpTempVerifySpeakerByFile_pargs::~kvpService_kvpTempVerifySpeakerByFile_pargs() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByFile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpTempVerifySpeakerByFile_pargs");

  xfer += oprot->writeFieldBegin("utt1", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->utt1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->sp_chan1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type1", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->utt_type1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt2", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->utt2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan2", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->sp_chan2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type2", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->utt_type2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpTempVerifySpeakerByFile_result::~kvpService_kvpTempVerifySpeakerByFile_result() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByFile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpTempVerifySpeakerByFile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpTempVerifySpeakerByFile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpTempVerifySpeakerByFile_presult::~kvpService_kvpTempVerifySpeakerByFile_presult() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByFile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByFile_args::~kvpService_kvpIdentifyTopSpeakerByFile_args() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByFile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->utt);
          this->__isset.utt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vp_node_arr.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->vp_node_arr.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += iprot->readString(this->vp_node_arr[_i22]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vp_node_arr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_num);
          this->__isset.node_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->top_n);
          this->__isset.top_n = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type);
          this->__isset.utt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sp_chan);
          this->__isset.sp_chan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIdentifyTopSpeakerByFile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIdentifyTopSpeakerByFile_args");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->utt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node_arr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vp_node_arr.size()));
    std::vector<std::string> ::const_iterator _iter23;
    for (_iter23 = this->vp_node_arr.begin(); _iter23 != this->vp_node_arr.end(); ++_iter23)
    {
      xfer += oprot->writeString((*_iter23));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->node_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("top_n", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->top_n);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->utt_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->sp_chan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByFile_pargs::~kvpService_kvpIdentifyTopSpeakerByFile_pargs() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByFile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIdentifyTopSpeakerByFile_pargs");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->utt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node_arr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->vp_node_arr)).size()));
    std::vector<std::string> ::const_iterator _iter24;
    for (_iter24 = (*(this->vp_node_arr)).begin(); _iter24 != (*(this->vp_node_arr)).end(); ++_iter24)
    {
      xfer += oprot->writeString((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->node_num)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("top_n", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->top_n)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->utt_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->sp_chan)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByFile_result::~kvpService_kvpIdentifyTopSpeakerByFile_result() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByFile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIdentifyTopSpeakerByFile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpIdentifyTopSpeakerByFile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByFile_presult::~kvpService_kvpIdentifyTopSpeakerByFile_presult() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByFile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpIvectorLoadByFile_args::~kvpService_kvpIvectorLoadByFile_args() throw() {
}


uint32_t kvpService_kvpIvectorLoadByFile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iv_file);
          this->__isset.iv_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIvectorLoadByFile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIvectorLoadByFile_args");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iv_file", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->iv_file);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIvectorLoadByFile_pargs::~kvpService_kvpIvectorLoadByFile_pargs() throw() {
}


uint32_t kvpService_kvpIvectorLoadByFile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIvectorLoadByFile_pargs");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iv_file", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->iv_file)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIvectorLoadByFile_result::~kvpService_kvpIvectorLoadByFile_result() throw() {
}


uint32_t kvpService_kvpIvectorLoadByFile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIvectorLoadByFile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpIvectorLoadByFile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIvectorLoadByFile_presult::~kvpService_kvpIvectorLoadByFile_presult() throw() {
}


uint32_t kvpService_kvpIvectorLoadByFile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpInsertNode_args::~kvpService_kvpInsertNode_args() throw() {
}


uint32_t kvpService_kvpInsertNode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpInsertNode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpInsertNode_args");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpInsertNode_pargs::~kvpService_kvpInsertNode_pargs() throw() {
}


uint32_t kvpService_kvpInsertNode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpInsertNode_pargs");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpInsertNode_result::~kvpService_kvpInsertNode_result() throw() {
}


uint32_t kvpService_kvpInsertNode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpInsertNode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpInsertNode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpInsertNode_presult::~kvpService_kvpInsertNode_presult() throw() {
}


uint32_t kvpService_kvpInsertNode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpDeleteNode_args::~kvpService_kvpDeleteNode_args() throw() {
}


uint32_t kvpService_kvpDeleteNode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpDeleteNode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpDeleteNode_args");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpDeleteNode_pargs::~kvpService_kvpDeleteNode_pargs() throw() {
}


uint32_t kvpService_kvpDeleteNode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpDeleteNode_pargs");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpDeleteNode_result::~kvpService_kvpDeleteNode_result() throw() {
}


uint32_t kvpService_kvpDeleteNode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpDeleteNode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpDeleteNode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpDeleteNode_presult::~kvpService_kvpDeleteNode_presult() throw() {
}


uint32_t kvpService_kvpDeleteNode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpMoveNode_args::~kvpService_kvpMoveNode_args() throw() {
}


uint32_t kvpService_kvpMoveNode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->spk_id);
          this->__isset.spk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin);
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpMoveNode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpMoveNode_args");

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->spk_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpMoveNode_pargs::~kvpService_kvpMoveNode_pargs() throw() {
}


uint32_t kvpService_kvpMoveNode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpMoveNode_pargs");

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->spk_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->origin)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->target)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpMoveNode_result::~kvpService_kvpMoveNode_result() throw() {
}


uint32_t kvpService_kvpMoveNode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpMoveNode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpMoveNode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpMoveNode_presult::~kvpService_kvpMoveNode_presult() throw() {
}


uint32_t kvpService_kvpMoveNode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpGetFingerprint_args::~kvpService_kvpGetFingerprint_args() throw() {
}


uint32_t kvpService_kvpGetFingerprint_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpGetFingerprint_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpGetFingerprint_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpGetFingerprint_pargs::~kvpService_kvpGetFingerprint_pargs() throw() {
}


uint32_t kvpService_kvpGetFingerprint_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpGetFingerprint_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpGetFingerprint_result::~kvpService_kvpGetFingerprint_result() throw() {
}


uint32_t kvpService_kvpGetFingerprint_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpGetFingerprint_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpGetFingerprint_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpGetFingerprint_presult::~kvpService_kvpGetFingerprint_presult() throw() {
}


uint32_t kvpService_kvpGetFingerprint_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_KvpGetLicenceInfo_args::~kvpService_KvpGetLicenceInfo_args() throw() {
}


uint32_t kvpService_KvpGetLicenceInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_KvpGetLicenceInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_KvpGetLicenceInfo_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_KvpGetLicenceInfo_pargs::~kvpService_KvpGetLicenceInfo_pargs() throw() {
}


uint32_t kvpService_KvpGetLicenceInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_KvpGetLicenceInfo_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_KvpGetLicenceInfo_result::~kvpService_KvpGetLicenceInfo_result() throw() {
}


uint32_t kvpService_KvpGetLicenceInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_KvpGetLicenceInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_KvpGetLicenceInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_KvpGetLicenceInfo_presult::~kvpService_KvpGetLicenceInfo_presult() throw() {
}


uint32_t kvpService_KvpGetLicenceInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpSetLicence_args::~kvpService_kvpSetLicence_args() throw() {
}


uint32_t kvpService_kvpSetLicence_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->licence);
          this->__isset.licence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpSetLicence_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpSetLicence_args");

  xfer += oprot->writeFieldBegin("licence", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->licence);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpSetLicence_pargs::~kvpService_kvpSetLicence_pargs() throw() {
}


uint32_t kvpService_kvpSetLicence_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpSetLicence_pargs");

  xfer += oprot->writeFieldBegin("licence", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->licence)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpSetLicence_result::~kvpService_kvpSetLicence_result() throw() {
}


uint32_t kvpService_kvpSetLicence_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpSetLicence_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpSetLicence_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpSetLicence_presult::~kvpService_kvpSetLicence_presult() throw() {
}


uint32_t kvpService_kvpSetLicence_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpIsLicenceValid_args::~kvpService_kvpIsLicenceValid_args() throw() {
}


uint32_t kvpService_kvpIsLicenceValid_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIsLicenceValid_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIsLicenceValid_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIsLicenceValid_pargs::~kvpService_kvpIsLicenceValid_pargs() throw() {
}


uint32_t kvpService_kvpIsLicenceValid_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIsLicenceValid_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIsLicenceValid_result::~kvpService_kvpIsLicenceValid_result() throw() {
}


uint32_t kvpService_kvpIsLicenceValid_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIsLicenceValid_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpIsLicenceValid_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIsLicenceValid_presult::~kvpService_kvpIsLicenceValid_presult() throw() {
}


uint32_t kvpService_kvpIsLicenceValid_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpRegisterSpeakerByStream_args::~kvpService_kvpRegisterSpeakerByStream_args() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByStream_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->utt.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->utt.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += iprot->readI16(this->utt[_i29]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.utt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_dir);
          this->__isset.vp_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->spk_id);
          this->__isset.spk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpRegisterSpeakerByStream_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpRegisterSpeakerByStream_args");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->utt.size()));
    std::vector<int16_t> ::const_iterator _iter30;
    for (_iter30 = this->utt.begin(); _iter30 != this->utt.end(); ++_iter30)
    {
      xfer += oprot->writeI16((*_iter30));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_dir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->vp_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->spk_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpRegisterSpeakerByStream_pargs::~kvpService_kvpRegisterSpeakerByStream_pargs() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByStream_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpRegisterSpeakerByStream_pargs");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*(this->utt)).size()));
    std::vector<int16_t> ::const_iterator _iter31;
    for (_iter31 = (*(this->utt)).begin(); _iter31 != (*(this->utt)).end(); ++_iter31)
    {
      xfer += oprot->writeI16((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_dir", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->vp_dir)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->spk_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpRegisterSpeakerByStream_result::~kvpService_kvpRegisterSpeakerByStream_result() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByStream_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpRegisterSpeakerByStream_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpRegisterSpeakerByStream_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpRegisterSpeakerByStream_presult::~kvpService_kvpRegisterSpeakerByStream_presult() throw() {
}


uint32_t kvpService_kvpRegisterSpeakerByStream_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByStream_args::~kvpService_kvpIdentifyTopSpeakerByStream_args() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByStream_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->utt.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->utt.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readI16(this->utt[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.utt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->vp_node_arr.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->vp_node_arr.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += iprot->readString(this->vp_node_arr[_i41]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.vp_node_arr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_num);
          this->__isset.node_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->top_n);
          this->__isset.top_n = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type);
          this->__isset.utt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIdentifyTopSpeakerByStream_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIdentifyTopSpeakerByStream_args");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->utt.size()));
    std::vector<int16_t> ::const_iterator _iter42;
    for (_iter42 = this->utt.begin(); _iter42 != this->utt.end(); ++_iter42)
    {
      xfer += oprot->writeI16((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node_arr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vp_node_arr.size()));
    std::vector<std::string> ::const_iterator _iter43;
    for (_iter43 = this->vp_node_arr.begin(); _iter43 != this->vp_node_arr.end(); ++_iter43)
    {
      xfer += oprot->writeString((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->node_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("top_n", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->top_n);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->utt_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByStream_pargs::~kvpService_kvpIdentifyTopSpeakerByStream_pargs() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByStream_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpIdentifyTopSpeakerByStream_pargs");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*(this->utt)).size()));
    std::vector<int16_t> ::const_iterator _iter44;
    for (_iter44 = (*(this->utt)).begin(); _iter44 != (*(this->utt)).end(); ++_iter44)
    {
      xfer += oprot->writeI16((*_iter44));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node_arr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->vp_node_arr)).size()));
    std::vector<std::string> ::const_iterator _iter45;
    for (_iter45 = (*(this->vp_node_arr)).begin(); _iter45 != (*(this->vp_node_arr)).end(); ++_iter45)
    {
      xfer += oprot->writeString((*_iter45));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->node_num)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("top_n", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->top_n)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->utt_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByStream_result::~kvpService_kvpIdentifyTopSpeakerByStream_result() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByStream_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpIdentifyTopSpeakerByStream_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpIdentifyTopSpeakerByStream_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpIdentifyTopSpeakerByStream_presult::~kvpService_kvpIdentifyTopSpeakerByStream_presult() throw() {
}


uint32_t kvpService_kvpIdentifyTopSpeakerByStream_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpVerifySpeakerByStream_args::~kvpService_kvpVerifySpeakerByStream_args() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByStream_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->utt.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->utt.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += iprot->readI16(this->utt[_i50]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.utt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->spk_id);
          this->__isset.spk_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type);
          this->__isset.utt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpVerifySpeakerByStream_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpVerifySpeakerByStream_args");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->utt.size()));
    std::vector<int16_t> ::const_iterator _iter51;
    for (_iter51 = this->utt.begin(); _iter51 != this->utt.end(); ++_iter51)
    {
      xfer += oprot->writeI16((*_iter51));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->spk_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->utt_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpVerifySpeakerByStream_pargs::~kvpService_kvpVerifySpeakerByStream_pargs() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByStream_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpVerifySpeakerByStream_pargs");

  xfer += oprot->writeFieldBegin("utt", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*(this->utt)).size()));
    std::vector<int16_t> ::const_iterator _iter52;
    for (_iter52 = (*(this->utt)).begin(); _iter52 != (*(this->utt)).end(); ++_iter52)
    {
      xfer += oprot->writeI16((*_iter52));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spk_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->spk_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->utt_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpVerifySpeakerByStream_result::~kvpService_kvpVerifySpeakerByStream_result() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByStream_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpVerifySpeakerByStream_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpVerifySpeakerByStream_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpVerifySpeakerByStream_presult::~kvpService_kvpVerifySpeakerByStream_presult() throw() {
}


uint32_t kvpService_kvpVerifySpeakerByStream_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpTempVerifySpeakerByStream_args::~kvpService_kvpTempVerifySpeakerByStream_args() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByStream_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->utt1.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->utt1.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readI16(this->utt1[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.utt1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sp_chan1);
          this->__isset.sp_chan1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type1);
          this->__isset.utt_type1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->utt2.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->utt2.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readI16(this->utt2[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.utt2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sp_chan2);
          this->__isset.sp_chan2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->utt_type2);
          this->__isset.utt_type2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpTempVerifySpeakerByStream_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpTempVerifySpeakerByStream_args");

  xfer += oprot->writeFieldBegin("utt1", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->utt1.size()));
    std::vector<int16_t> ::const_iterator _iter63;
    for (_iter63 = this->utt1.begin(); _iter63 != this->utt1.end(); ++_iter63)
    {
      xfer += oprot->writeI16((*_iter63));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->sp_chan1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type1", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->utt_type1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt2", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->utt2.size()));
    std::vector<int16_t> ::const_iterator _iter64;
    for (_iter64 = this->utt2.begin(); _iter64 != this->utt2.end(); ++_iter64)
    {
      xfer += oprot->writeI16((*_iter64));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan2", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sp_chan2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type2", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->utt_type2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpTempVerifySpeakerByStream_pargs::~kvpService_kvpTempVerifySpeakerByStream_pargs() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByStream_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpTempVerifySpeakerByStream_pargs");

  xfer += oprot->writeFieldBegin("utt1", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*(this->utt1)).size()));
    std::vector<int16_t> ::const_iterator _iter65;
    for (_iter65 = (*(this->utt1)).begin(); _iter65 != (*(this->utt1)).end(); ++_iter65)
    {
      xfer += oprot->writeI16((*_iter65));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan1", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->sp_chan1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type1", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->utt_type1)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt2", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*(this->utt2)).size()));
    std::vector<int16_t> ::const_iterator _iter66;
    for (_iter66 = (*(this->utt2)).begin(); _iter66 != (*(this->utt2)).end(); ++_iter66)
    {
      xfer += oprot->writeI16((*_iter66));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sp_chan2", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->sp_chan2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("utt_type2", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->utt_type2)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpTempVerifySpeakerByStream_result::~kvpService_kvpTempVerifySpeakerByStream_result() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByStream_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpTempVerifySpeakerByStream_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpTempVerifySpeakerByStream_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpTempVerifySpeakerByStream_presult::~kvpService_kvpTempVerifySpeakerByStream_presult() throw() {
}


uint32_t kvpService_kvpTempVerifySpeakerByStream_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


kvpService_kvpNodeGetList_args::~kvpService_kvpNodeGetList_args() throw() {
}


uint32_t kvpService_kvpNodeGetList_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vp_node);
          this->__isset.vp_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpNodeGetList_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpNodeGetList_args");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->vp_node);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpNodeGetList_pargs::~kvpService_kvpNodeGetList_pargs() throw() {
}


uint32_t kvpService_kvpNodeGetList_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kvpService_kvpNodeGetList_pargs");

  xfer += oprot->writeFieldBegin("vp_node", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->vp_node)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpNodeGetList_result::~kvpService_kvpNodeGetList_result() throw() {
}


uint32_t kvpService_kvpNodeGetList_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->success.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readString(this->success[_i71]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kvpService_kvpNodeGetList_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("kvpService_kvpNodeGetList_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter72;
      for (_iter72 = this->success.begin(); _iter72 != this->success.end(); ++_iter72)
      {
        xfer += oprot->writeString((*_iter72));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


kvpService_kvpNodeGetList_presult::~kvpService_kvpNodeGetList_presult() throw() {
}


uint32_t kvpService_kvpNodeGetList_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            (*(this->success)).resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += iprot->readString((*(this->success))[_i77]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void kvpServiceClient::kvpPing(std::string& _return)
{
  send_kvpPing();
  recv_kvpPing(_return);
}

void kvpServiceClient::send_kvpPing()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpPing", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpPing_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpPing(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpPing") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpPing_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpPing failed: unknown result");
}

void kvpServiceClient::kvpGetUttInfo(Rpc_UttInfo& _return, const std::string& wavpath)
{
  send_kvpGetUttInfo(wavpath);
  recv_kvpGetUttInfo(_return);
}

void kvpServiceClient::send_kvpGetUttInfo(const std::string& wavpath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpGetUttInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpGetUttInfo_pargs args;
  args.wavpath = &wavpath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpGetUttInfo(Rpc_UttInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpGetUttInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpGetUttInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpGetUttInfo failed: unknown result");
}

int32_t kvpServiceClient::kvpModelRemoveBySpkid(const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  send_kvpModelRemoveBySpkid(vp_node, vp_dir, spk_id);
  return recv_kvpModelRemoveBySpkid();
}

void kvpServiceClient::send_kvpModelRemoveBySpkid(const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpModelRemoveBySpkid", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpModelRemoveBySpkid_pargs args;
  args.vp_node = &vp_node;
  args.vp_dir = &vp_dir;
  args.spk_id = &spk_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t kvpServiceClient::recv_kvpModelRemoveBySpkid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpModelRemoveBySpkid") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  kvpService_kvpModelRemoveBySpkid_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpModelRemoveBySpkid failed: unknown result");
}

void kvpServiceClient::kvpRegisterSpeakerByFile(Rpc_ModelInfo& _return, const std::string& utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id, const int32_t sp_chan)
{
  send_kvpRegisterSpeakerByFile(utt, vp_node, vp_dir, spk_id, sp_chan);
  recv_kvpRegisterSpeakerByFile(_return);
}

void kvpServiceClient::send_kvpRegisterSpeakerByFile(const std::string& utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id, const int32_t sp_chan)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpRegisterSpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpRegisterSpeakerByFile_pargs args;
  args.utt = &utt;
  args.vp_node = &vp_node;
  args.vp_dir = &vp_dir;
  args.spk_id = &spk_id;
  args.sp_chan = &sp_chan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpRegisterSpeakerByFile(Rpc_ModelInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpRegisterSpeakerByFile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpRegisterSpeakerByFile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpRegisterSpeakerByFile failed: unknown result");
}

void kvpServiceClient::kvpVerifySpeakerByFile(Rpc_ScoreInfo& _return, const std::string& utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type, const int32_t sp_chan)
{
  send_kvpVerifySpeakerByFile(utt, spk_id, vp_node, utt_type, sp_chan);
  recv_kvpVerifySpeakerByFile(_return);
}

void kvpServiceClient::send_kvpVerifySpeakerByFile(const std::string& utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type, const int32_t sp_chan)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpVerifySpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpVerifySpeakerByFile_pargs args;
  args.utt = &utt;
  args.spk_id = &spk_id;
  args.vp_node = &vp_node;
  args.utt_type = &utt_type;
  args.sp_chan = &sp_chan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpVerifySpeakerByFile(Rpc_ScoreInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpVerifySpeakerByFile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpVerifySpeakerByFile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpVerifySpeakerByFile failed: unknown result");
}

void kvpServiceClient::kvpTempVerifySpeakerByFile(Rpc_ScoreInfo& _return, const std::string& utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::string& utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  send_kvpTempVerifySpeakerByFile(utt1, sp_chan1, utt_type1, utt2, sp_chan2, utt_type2);
  recv_kvpTempVerifySpeakerByFile(_return);
}

void kvpServiceClient::send_kvpTempVerifySpeakerByFile(const std::string& utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::string& utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpTempVerifySpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpTempVerifySpeakerByFile_pargs args;
  args.utt1 = &utt1;
  args.sp_chan1 = &sp_chan1;
  args.utt_type1 = &utt_type1;
  args.utt2 = &utt2;
  args.sp_chan2 = &sp_chan2;
  args.utt_type2 = &utt_type2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpTempVerifySpeakerByFile(Rpc_ScoreInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpTempVerifySpeakerByFile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpTempVerifySpeakerByFile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpTempVerifySpeakerByFile failed: unknown result");
}

void kvpServiceClient::kvpIdentifyTopSpeakerByFile(Rpc_TopSpeakerInfo& _return, const std::string& utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type, const int32_t sp_chan)
{
  send_kvpIdentifyTopSpeakerByFile(utt, vp_node_arr, node_num, top_n, utt_type, sp_chan);
  recv_kvpIdentifyTopSpeakerByFile(_return);
}

void kvpServiceClient::send_kvpIdentifyTopSpeakerByFile(const std::string& utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type, const int32_t sp_chan)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpIdentifyTopSpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIdentifyTopSpeakerByFile_pargs args;
  args.utt = &utt;
  args.vp_node_arr = &vp_node_arr;
  args.node_num = &node_num;
  args.top_n = &top_n;
  args.utt_type = &utt_type;
  args.sp_chan = &sp_chan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpIdentifyTopSpeakerByFile(Rpc_TopSpeakerInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpIdentifyTopSpeakerByFile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpIdentifyTopSpeakerByFile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIdentifyTopSpeakerByFile failed: unknown result");
}

int32_t kvpServiceClient::kvpIvectorLoadByFile(const std::string& vp_node, const std::string& iv_file)
{
  send_kvpIvectorLoadByFile(vp_node, iv_file);
  return recv_kvpIvectorLoadByFile();
}

void kvpServiceClient::send_kvpIvectorLoadByFile(const std::string& vp_node, const std::string& iv_file)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpIvectorLoadByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIvectorLoadByFile_pargs args;
  args.vp_node = &vp_node;
  args.iv_file = &iv_file;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t kvpServiceClient::recv_kvpIvectorLoadByFile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpIvectorLoadByFile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  kvpService_kvpIvectorLoadByFile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIvectorLoadByFile failed: unknown result");
}

int32_t kvpServiceClient::kvpInsertNode(const std::string& vp_node)
{
  send_kvpInsertNode(vp_node);
  return recv_kvpInsertNode();
}

void kvpServiceClient::send_kvpInsertNode(const std::string& vp_node)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpInsertNode", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpInsertNode_pargs args;
  args.vp_node = &vp_node;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t kvpServiceClient::recv_kvpInsertNode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpInsertNode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  kvpService_kvpInsertNode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpInsertNode failed: unknown result");
}

int32_t kvpServiceClient::kvpDeleteNode(const std::string& vp_node)
{
  send_kvpDeleteNode(vp_node);
  return recv_kvpDeleteNode();
}

void kvpServiceClient::send_kvpDeleteNode(const std::string& vp_node)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpDeleteNode", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpDeleteNode_pargs args;
  args.vp_node = &vp_node;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t kvpServiceClient::recv_kvpDeleteNode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpDeleteNode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  kvpService_kvpDeleteNode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpDeleteNode failed: unknown result");
}

int32_t kvpServiceClient::kvpMoveNode(const std::string& spk_id, const std::string& origin, const std::string& target)
{
  send_kvpMoveNode(spk_id, origin, target);
  return recv_kvpMoveNode();
}

void kvpServiceClient::send_kvpMoveNode(const std::string& spk_id, const std::string& origin, const std::string& target)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpMoveNode", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpMoveNode_pargs args;
  args.spk_id = &spk_id;
  args.origin = &origin;
  args.target = &target;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t kvpServiceClient::recv_kvpMoveNode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpMoveNode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  kvpService_kvpMoveNode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpMoveNode failed: unknown result");
}

void kvpServiceClient::kvpGetFingerprint(std::string& _return)
{
  send_kvpGetFingerprint();
  recv_kvpGetFingerprint(_return);
}

void kvpServiceClient::send_kvpGetFingerprint()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpGetFingerprint", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpGetFingerprint_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpGetFingerprint(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpGetFingerprint") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpGetFingerprint_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpGetFingerprint failed: unknown result");
}

void kvpServiceClient::KvpGetLicenceInfo(Rpc_LicenceInfo& _return)
{
  send_KvpGetLicenceInfo();
  recv_KvpGetLicenceInfo(_return);
}

void kvpServiceClient::send_KvpGetLicenceInfo()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("KvpGetLicenceInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_KvpGetLicenceInfo_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_KvpGetLicenceInfo(Rpc_LicenceInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("KvpGetLicenceInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_KvpGetLicenceInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "KvpGetLicenceInfo failed: unknown result");
}

int32_t kvpServiceClient::kvpSetLicence(const std::string& licence)
{
  send_kvpSetLicence(licence);
  return recv_kvpSetLicence();
}

void kvpServiceClient::send_kvpSetLicence(const std::string& licence)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpSetLicence", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpSetLicence_pargs args;
  args.licence = &licence;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t kvpServiceClient::recv_kvpSetLicence()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpSetLicence") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  kvpService_kvpSetLicence_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpSetLicence failed: unknown result");
}

bool kvpServiceClient::kvpIsLicenceValid()
{
  send_kvpIsLicenceValid();
  return recv_kvpIsLicenceValid();
}

void kvpServiceClient::send_kvpIsLicenceValid()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpIsLicenceValid", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIsLicenceValid_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool kvpServiceClient::recv_kvpIsLicenceValid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpIsLicenceValid") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  kvpService_kvpIsLicenceValid_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIsLicenceValid failed: unknown result");
}

void kvpServiceClient::kvpRegisterSpeakerByStream(Rpc_ModelInfo& _return, const std::vector<int16_t> & utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  send_kvpRegisterSpeakerByStream(utt, vp_node, vp_dir, spk_id);
  recv_kvpRegisterSpeakerByStream(_return);
}

void kvpServiceClient::send_kvpRegisterSpeakerByStream(const std::vector<int16_t> & utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpRegisterSpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpRegisterSpeakerByStream_pargs args;
  args.utt = &utt;
  args.vp_node = &vp_node;
  args.vp_dir = &vp_dir;
  args.spk_id = &spk_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpRegisterSpeakerByStream(Rpc_ModelInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpRegisterSpeakerByStream") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpRegisterSpeakerByStream_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpRegisterSpeakerByStream failed: unknown result");
}

void kvpServiceClient::kvpIdentifyTopSpeakerByStream(Rpc_TopSpeakerInfo& _return, const std::vector<int16_t> & utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type)
{
  send_kvpIdentifyTopSpeakerByStream(utt, vp_node_arr, node_num, top_n, utt_type);
  recv_kvpIdentifyTopSpeakerByStream(_return);
}

void kvpServiceClient::send_kvpIdentifyTopSpeakerByStream(const std::vector<int16_t> & utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpIdentifyTopSpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIdentifyTopSpeakerByStream_pargs args;
  args.utt = &utt;
  args.vp_node_arr = &vp_node_arr;
  args.node_num = &node_num;
  args.top_n = &top_n;
  args.utt_type = &utt_type;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpIdentifyTopSpeakerByStream(Rpc_TopSpeakerInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpIdentifyTopSpeakerByStream") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpIdentifyTopSpeakerByStream_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIdentifyTopSpeakerByStream failed: unknown result");
}

void kvpServiceClient::kvpVerifySpeakerByStream(Rpc_ScoreInfo& _return, const std::vector<int16_t> & utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type)
{
  send_kvpVerifySpeakerByStream(utt, spk_id, vp_node, utt_type);
  recv_kvpVerifySpeakerByStream(_return);
}

void kvpServiceClient::send_kvpVerifySpeakerByStream(const std::vector<int16_t> & utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpVerifySpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpVerifySpeakerByStream_pargs args;
  args.utt = &utt;
  args.spk_id = &spk_id;
  args.vp_node = &vp_node;
  args.utt_type = &utt_type;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpVerifySpeakerByStream(Rpc_ScoreInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpVerifySpeakerByStream") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpVerifySpeakerByStream_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpVerifySpeakerByStream failed: unknown result");
}

void kvpServiceClient::kvpTempVerifySpeakerByStream(Rpc_ScoreInfo& _return, const std::vector<int16_t> & utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::vector<int16_t> & utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  send_kvpTempVerifySpeakerByStream(utt1, sp_chan1, utt_type1, utt2, sp_chan2, utt_type2);
  recv_kvpTempVerifySpeakerByStream(_return);
}

void kvpServiceClient::send_kvpTempVerifySpeakerByStream(const std::vector<int16_t> & utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::vector<int16_t> & utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpTempVerifySpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpTempVerifySpeakerByStream_pargs args;
  args.utt1 = &utt1;
  args.sp_chan1 = &sp_chan1;
  args.utt_type1 = &utt_type1;
  args.utt2 = &utt2;
  args.sp_chan2 = &sp_chan2;
  args.utt_type2 = &utt_type2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpTempVerifySpeakerByStream(Rpc_ScoreInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpTempVerifySpeakerByStream") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpTempVerifySpeakerByStream_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpTempVerifySpeakerByStream failed: unknown result");
}

void kvpServiceClient::kvpNodeGetList(std::vector<std::string> & _return, const std::string& vp_node)
{
  send_kvpNodeGetList(vp_node);
  recv_kvpNodeGetList(_return);
}

void kvpServiceClient::send_kvpNodeGetList(const std::string& vp_node)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("kvpNodeGetList", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpNodeGetList_pargs args;
  args.vp_node = &vp_node;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void kvpServiceClient::recv_kvpNodeGetList(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("kvpNodeGetList") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  kvpService_kvpNodeGetList_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpNodeGetList failed: unknown result");
}

bool kvpServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void kvpServiceProcessor::process_kvpPing(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpPing", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpPing");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpPing");
  }

  kvpService_kvpPing_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpPing", bytes);
  }

  kvpService_kvpPing_result result;
  try {
    iface_->kvpPing(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpPing");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpPing", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpPing");
  }

  oprot->writeMessageBegin("kvpPing", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpPing", bytes);
  }
}

void kvpServiceProcessor::process_kvpGetUttInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpGetUttInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpGetUttInfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpGetUttInfo");
  }

  kvpService_kvpGetUttInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpGetUttInfo", bytes);
  }

  kvpService_kvpGetUttInfo_result result;
  try {
    iface_->kvpGetUttInfo(result.success, args.wavpath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpGetUttInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpGetUttInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpGetUttInfo");
  }

  oprot->writeMessageBegin("kvpGetUttInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpGetUttInfo", bytes);
  }
}

void kvpServiceProcessor::process_kvpModelRemoveBySpkid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpModelRemoveBySpkid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpModelRemoveBySpkid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpModelRemoveBySpkid");
  }

  kvpService_kvpModelRemoveBySpkid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpModelRemoveBySpkid", bytes);
  }

  kvpService_kvpModelRemoveBySpkid_result result;
  try {
    result.success = iface_->kvpModelRemoveBySpkid(args.vp_node, args.vp_dir, args.spk_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpModelRemoveBySpkid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpModelRemoveBySpkid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpModelRemoveBySpkid");
  }

  oprot->writeMessageBegin("kvpModelRemoveBySpkid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpModelRemoveBySpkid", bytes);
  }
}

void kvpServiceProcessor::process_kvpRegisterSpeakerByFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpRegisterSpeakerByFile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpRegisterSpeakerByFile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpRegisterSpeakerByFile");
  }

  kvpService_kvpRegisterSpeakerByFile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpRegisterSpeakerByFile", bytes);
  }

  kvpService_kvpRegisterSpeakerByFile_result result;
  try {
    iface_->kvpRegisterSpeakerByFile(result.success, args.utt, args.vp_node, args.vp_dir, args.spk_id, args.sp_chan);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpRegisterSpeakerByFile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpRegisterSpeakerByFile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpRegisterSpeakerByFile");
  }

  oprot->writeMessageBegin("kvpRegisterSpeakerByFile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpRegisterSpeakerByFile", bytes);
  }
}

void kvpServiceProcessor::process_kvpVerifySpeakerByFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpVerifySpeakerByFile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpVerifySpeakerByFile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpVerifySpeakerByFile");
  }

  kvpService_kvpVerifySpeakerByFile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpVerifySpeakerByFile", bytes);
  }

  kvpService_kvpVerifySpeakerByFile_result result;
  try {
    iface_->kvpVerifySpeakerByFile(result.success, args.utt, args.spk_id, args.vp_node, args.utt_type, args.sp_chan);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpVerifySpeakerByFile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpVerifySpeakerByFile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpVerifySpeakerByFile");
  }

  oprot->writeMessageBegin("kvpVerifySpeakerByFile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpVerifySpeakerByFile", bytes);
  }
}

void kvpServiceProcessor::process_kvpTempVerifySpeakerByFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpTempVerifySpeakerByFile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpTempVerifySpeakerByFile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpTempVerifySpeakerByFile");
  }

  kvpService_kvpTempVerifySpeakerByFile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpTempVerifySpeakerByFile", bytes);
  }

  kvpService_kvpTempVerifySpeakerByFile_result result;
  try {
    iface_->kvpTempVerifySpeakerByFile(result.success, args.utt1, args.sp_chan1, args.utt_type1, args.utt2, args.sp_chan2, args.utt_type2);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpTempVerifySpeakerByFile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpTempVerifySpeakerByFile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpTempVerifySpeakerByFile");
  }

  oprot->writeMessageBegin("kvpTempVerifySpeakerByFile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpTempVerifySpeakerByFile", bytes);
  }
}

void kvpServiceProcessor::process_kvpIdentifyTopSpeakerByFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpIdentifyTopSpeakerByFile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpIdentifyTopSpeakerByFile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpIdentifyTopSpeakerByFile");
  }

  kvpService_kvpIdentifyTopSpeakerByFile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpIdentifyTopSpeakerByFile", bytes);
  }

  kvpService_kvpIdentifyTopSpeakerByFile_result result;
  try {
    iface_->kvpIdentifyTopSpeakerByFile(result.success, args.utt, args.vp_node_arr, args.node_num, args.top_n, args.utt_type, args.sp_chan);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpIdentifyTopSpeakerByFile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpIdentifyTopSpeakerByFile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpIdentifyTopSpeakerByFile");
  }

  oprot->writeMessageBegin("kvpIdentifyTopSpeakerByFile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpIdentifyTopSpeakerByFile", bytes);
  }
}

void kvpServiceProcessor::process_kvpIvectorLoadByFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpIvectorLoadByFile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpIvectorLoadByFile");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpIvectorLoadByFile");
  }

  kvpService_kvpIvectorLoadByFile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpIvectorLoadByFile", bytes);
  }

  kvpService_kvpIvectorLoadByFile_result result;
  try {
    result.success = iface_->kvpIvectorLoadByFile(args.vp_node, args.iv_file);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpIvectorLoadByFile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpIvectorLoadByFile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpIvectorLoadByFile");
  }

  oprot->writeMessageBegin("kvpIvectorLoadByFile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpIvectorLoadByFile", bytes);
  }
}

void kvpServiceProcessor::process_kvpInsertNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpInsertNode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpInsertNode");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpInsertNode");
  }

  kvpService_kvpInsertNode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpInsertNode", bytes);
  }

  kvpService_kvpInsertNode_result result;
  try {
    result.success = iface_->kvpInsertNode(args.vp_node);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpInsertNode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpInsertNode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpInsertNode");
  }

  oprot->writeMessageBegin("kvpInsertNode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpInsertNode", bytes);
  }
}

void kvpServiceProcessor::process_kvpDeleteNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpDeleteNode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpDeleteNode");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpDeleteNode");
  }

  kvpService_kvpDeleteNode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpDeleteNode", bytes);
  }

  kvpService_kvpDeleteNode_result result;
  try {
    result.success = iface_->kvpDeleteNode(args.vp_node);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpDeleteNode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpDeleteNode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpDeleteNode");
  }

  oprot->writeMessageBegin("kvpDeleteNode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpDeleteNode", bytes);
  }
}

void kvpServiceProcessor::process_kvpMoveNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpMoveNode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpMoveNode");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpMoveNode");
  }

  kvpService_kvpMoveNode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpMoveNode", bytes);
  }

  kvpService_kvpMoveNode_result result;
  try {
    result.success = iface_->kvpMoveNode(args.spk_id, args.origin, args.target);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpMoveNode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpMoveNode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpMoveNode");
  }

  oprot->writeMessageBegin("kvpMoveNode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpMoveNode", bytes);
  }
}

void kvpServiceProcessor::process_kvpGetFingerprint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpGetFingerprint", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpGetFingerprint");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpGetFingerprint");
  }

  kvpService_kvpGetFingerprint_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpGetFingerprint", bytes);
  }

  kvpService_kvpGetFingerprint_result result;
  try {
    iface_->kvpGetFingerprint(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpGetFingerprint");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpGetFingerprint", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpGetFingerprint");
  }

  oprot->writeMessageBegin("kvpGetFingerprint", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpGetFingerprint", bytes);
  }
}

void kvpServiceProcessor::process_KvpGetLicenceInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.KvpGetLicenceInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.KvpGetLicenceInfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.KvpGetLicenceInfo");
  }

  kvpService_KvpGetLicenceInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.KvpGetLicenceInfo", bytes);
  }

  kvpService_KvpGetLicenceInfo_result result;
  try {
    iface_->KvpGetLicenceInfo(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.KvpGetLicenceInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("KvpGetLicenceInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.KvpGetLicenceInfo");
  }

  oprot->writeMessageBegin("KvpGetLicenceInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.KvpGetLicenceInfo", bytes);
  }
}

void kvpServiceProcessor::process_kvpSetLicence(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpSetLicence", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpSetLicence");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpSetLicence");
  }

  kvpService_kvpSetLicence_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpSetLicence", bytes);
  }

  kvpService_kvpSetLicence_result result;
  try {
    result.success = iface_->kvpSetLicence(args.licence);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpSetLicence");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpSetLicence", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpSetLicence");
  }

  oprot->writeMessageBegin("kvpSetLicence", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpSetLicence", bytes);
  }
}

void kvpServiceProcessor::process_kvpIsLicenceValid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpIsLicenceValid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpIsLicenceValid");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpIsLicenceValid");
  }

  kvpService_kvpIsLicenceValid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpIsLicenceValid", bytes);
  }

  kvpService_kvpIsLicenceValid_result result;
  try {
    result.success = iface_->kvpIsLicenceValid();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpIsLicenceValid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpIsLicenceValid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpIsLicenceValid");
  }

  oprot->writeMessageBegin("kvpIsLicenceValid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpIsLicenceValid", bytes);
  }
}

void kvpServiceProcessor::process_kvpRegisterSpeakerByStream(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpRegisterSpeakerByStream", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpRegisterSpeakerByStream");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpRegisterSpeakerByStream");
  }

  kvpService_kvpRegisterSpeakerByStream_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpRegisterSpeakerByStream", bytes);
  }

  kvpService_kvpRegisterSpeakerByStream_result result;
  try {
    iface_->kvpRegisterSpeakerByStream(result.success, args.utt, args.vp_node, args.vp_dir, args.spk_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpRegisterSpeakerByStream");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpRegisterSpeakerByStream", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpRegisterSpeakerByStream");
  }

  oprot->writeMessageBegin("kvpRegisterSpeakerByStream", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpRegisterSpeakerByStream", bytes);
  }
}

void kvpServiceProcessor::process_kvpIdentifyTopSpeakerByStream(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpIdentifyTopSpeakerByStream", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpIdentifyTopSpeakerByStream");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpIdentifyTopSpeakerByStream");
  }

  kvpService_kvpIdentifyTopSpeakerByStream_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpIdentifyTopSpeakerByStream", bytes);
  }

  kvpService_kvpIdentifyTopSpeakerByStream_result result;
  try {
    iface_->kvpIdentifyTopSpeakerByStream(result.success, args.utt, args.vp_node_arr, args.node_num, args.top_n, args.utt_type);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpIdentifyTopSpeakerByStream");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpIdentifyTopSpeakerByStream", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpIdentifyTopSpeakerByStream");
  }

  oprot->writeMessageBegin("kvpIdentifyTopSpeakerByStream", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpIdentifyTopSpeakerByStream", bytes);
  }
}

void kvpServiceProcessor::process_kvpVerifySpeakerByStream(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpVerifySpeakerByStream", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpVerifySpeakerByStream");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpVerifySpeakerByStream");
  }

  kvpService_kvpVerifySpeakerByStream_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpVerifySpeakerByStream", bytes);
  }

  kvpService_kvpVerifySpeakerByStream_result result;
  try {
    iface_->kvpVerifySpeakerByStream(result.success, args.utt, args.spk_id, args.vp_node, args.utt_type);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpVerifySpeakerByStream");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpVerifySpeakerByStream", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpVerifySpeakerByStream");
  }

  oprot->writeMessageBegin("kvpVerifySpeakerByStream", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpVerifySpeakerByStream", bytes);
  }
}

void kvpServiceProcessor::process_kvpTempVerifySpeakerByStream(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpTempVerifySpeakerByStream", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpTempVerifySpeakerByStream");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpTempVerifySpeakerByStream");
  }

  kvpService_kvpTempVerifySpeakerByStream_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpTempVerifySpeakerByStream", bytes);
  }

  kvpService_kvpTempVerifySpeakerByStream_result result;
  try {
    iface_->kvpTempVerifySpeakerByStream(result.success, args.utt1, args.sp_chan1, args.utt_type1, args.utt2, args.sp_chan2, args.utt_type2);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpTempVerifySpeakerByStream");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpTempVerifySpeakerByStream", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpTempVerifySpeakerByStream");
  }

  oprot->writeMessageBegin("kvpTempVerifySpeakerByStream", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpTempVerifySpeakerByStream", bytes);
  }
}

void kvpServiceProcessor::process_kvpNodeGetList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("kvpService.kvpNodeGetList", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "kvpService.kvpNodeGetList");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "kvpService.kvpNodeGetList");
  }

  kvpService_kvpNodeGetList_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "kvpService.kvpNodeGetList", bytes);
  }

  kvpService_kvpNodeGetList_result result;
  try {
    iface_->kvpNodeGetList(result.success, args.vp_node);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "kvpService.kvpNodeGetList");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("kvpNodeGetList", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "kvpService.kvpNodeGetList");
  }

  oprot->writeMessageBegin("kvpNodeGetList", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "kvpService.kvpNodeGetList", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > kvpServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< kvpServiceIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< kvpServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new kvpServiceProcessor(handler));
  return processor;
}

void kvpServiceConcurrentClient::kvpPing(std::string& _return)
{
  int32_t seqid = send_kvpPing();
  recv_kvpPing(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpPing()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpPing", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpPing_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpPing(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpPing") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpPing_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpPing failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpGetUttInfo(Rpc_UttInfo& _return, const std::string& wavpath)
{
  int32_t seqid = send_kvpGetUttInfo(wavpath);
  recv_kvpGetUttInfo(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpGetUttInfo(const std::string& wavpath)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpGetUttInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpGetUttInfo_pargs args;
  args.wavpath = &wavpath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpGetUttInfo(Rpc_UttInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpGetUttInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpGetUttInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpGetUttInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t kvpServiceConcurrentClient::kvpModelRemoveBySpkid(const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  int32_t seqid = send_kvpModelRemoveBySpkid(vp_node, vp_dir, spk_id);
  return recv_kvpModelRemoveBySpkid(seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpModelRemoveBySpkid(const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpModelRemoveBySpkid", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpModelRemoveBySpkid_pargs args;
  args.vp_node = &vp_node;
  args.vp_dir = &vp_dir;
  args.spk_id = &spk_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t kvpServiceConcurrentClient::recv_kvpModelRemoveBySpkid(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpModelRemoveBySpkid") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      kvpService_kvpModelRemoveBySpkid_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpModelRemoveBySpkid failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpRegisterSpeakerByFile(Rpc_ModelInfo& _return, const std::string& utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id, const int32_t sp_chan)
{
  int32_t seqid = send_kvpRegisterSpeakerByFile(utt, vp_node, vp_dir, spk_id, sp_chan);
  recv_kvpRegisterSpeakerByFile(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpRegisterSpeakerByFile(const std::string& utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id, const int32_t sp_chan)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpRegisterSpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpRegisterSpeakerByFile_pargs args;
  args.utt = &utt;
  args.vp_node = &vp_node;
  args.vp_dir = &vp_dir;
  args.spk_id = &spk_id;
  args.sp_chan = &sp_chan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpRegisterSpeakerByFile(Rpc_ModelInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpRegisterSpeakerByFile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpRegisterSpeakerByFile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpRegisterSpeakerByFile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpVerifySpeakerByFile(Rpc_ScoreInfo& _return, const std::string& utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type, const int32_t sp_chan)
{
  int32_t seqid = send_kvpVerifySpeakerByFile(utt, spk_id, vp_node, utt_type, sp_chan);
  recv_kvpVerifySpeakerByFile(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpVerifySpeakerByFile(const std::string& utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type, const int32_t sp_chan)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpVerifySpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpVerifySpeakerByFile_pargs args;
  args.utt = &utt;
  args.spk_id = &spk_id;
  args.vp_node = &vp_node;
  args.utt_type = &utt_type;
  args.sp_chan = &sp_chan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpVerifySpeakerByFile(Rpc_ScoreInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpVerifySpeakerByFile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpVerifySpeakerByFile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpVerifySpeakerByFile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpTempVerifySpeakerByFile(Rpc_ScoreInfo& _return, const std::string& utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::string& utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  int32_t seqid = send_kvpTempVerifySpeakerByFile(utt1, sp_chan1, utt_type1, utt2, sp_chan2, utt_type2);
  recv_kvpTempVerifySpeakerByFile(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpTempVerifySpeakerByFile(const std::string& utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::string& utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpTempVerifySpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpTempVerifySpeakerByFile_pargs args;
  args.utt1 = &utt1;
  args.sp_chan1 = &sp_chan1;
  args.utt_type1 = &utt_type1;
  args.utt2 = &utt2;
  args.sp_chan2 = &sp_chan2;
  args.utt_type2 = &utt_type2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpTempVerifySpeakerByFile(Rpc_ScoreInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpTempVerifySpeakerByFile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpTempVerifySpeakerByFile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpTempVerifySpeakerByFile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpIdentifyTopSpeakerByFile(Rpc_TopSpeakerInfo& _return, const std::string& utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type, const int32_t sp_chan)
{
  int32_t seqid = send_kvpIdentifyTopSpeakerByFile(utt, vp_node_arr, node_num, top_n, utt_type, sp_chan);
  recv_kvpIdentifyTopSpeakerByFile(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpIdentifyTopSpeakerByFile(const std::string& utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type, const int32_t sp_chan)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpIdentifyTopSpeakerByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIdentifyTopSpeakerByFile_pargs args;
  args.utt = &utt;
  args.vp_node_arr = &vp_node_arr;
  args.node_num = &node_num;
  args.top_n = &top_n;
  args.utt_type = &utt_type;
  args.sp_chan = &sp_chan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpIdentifyTopSpeakerByFile(Rpc_TopSpeakerInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpIdentifyTopSpeakerByFile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpIdentifyTopSpeakerByFile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIdentifyTopSpeakerByFile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t kvpServiceConcurrentClient::kvpIvectorLoadByFile(const std::string& vp_node, const std::string& iv_file)
{
  int32_t seqid = send_kvpIvectorLoadByFile(vp_node, iv_file);
  return recv_kvpIvectorLoadByFile(seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpIvectorLoadByFile(const std::string& vp_node, const std::string& iv_file)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpIvectorLoadByFile", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIvectorLoadByFile_pargs args;
  args.vp_node = &vp_node;
  args.iv_file = &iv_file;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t kvpServiceConcurrentClient::recv_kvpIvectorLoadByFile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpIvectorLoadByFile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      kvpService_kvpIvectorLoadByFile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIvectorLoadByFile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t kvpServiceConcurrentClient::kvpInsertNode(const std::string& vp_node)
{
  int32_t seqid = send_kvpInsertNode(vp_node);
  return recv_kvpInsertNode(seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpInsertNode(const std::string& vp_node)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpInsertNode", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpInsertNode_pargs args;
  args.vp_node = &vp_node;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t kvpServiceConcurrentClient::recv_kvpInsertNode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpInsertNode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      kvpService_kvpInsertNode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpInsertNode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t kvpServiceConcurrentClient::kvpDeleteNode(const std::string& vp_node)
{
  int32_t seqid = send_kvpDeleteNode(vp_node);
  return recv_kvpDeleteNode(seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpDeleteNode(const std::string& vp_node)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpDeleteNode", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpDeleteNode_pargs args;
  args.vp_node = &vp_node;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t kvpServiceConcurrentClient::recv_kvpDeleteNode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpDeleteNode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      kvpService_kvpDeleteNode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpDeleteNode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t kvpServiceConcurrentClient::kvpMoveNode(const std::string& spk_id, const std::string& origin, const std::string& target)
{
  int32_t seqid = send_kvpMoveNode(spk_id, origin, target);
  return recv_kvpMoveNode(seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpMoveNode(const std::string& spk_id, const std::string& origin, const std::string& target)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpMoveNode", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpMoveNode_pargs args;
  args.spk_id = &spk_id;
  args.origin = &origin;
  args.target = &target;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t kvpServiceConcurrentClient::recv_kvpMoveNode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpMoveNode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      kvpService_kvpMoveNode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpMoveNode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpGetFingerprint(std::string& _return)
{
  int32_t seqid = send_kvpGetFingerprint();
  recv_kvpGetFingerprint(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpGetFingerprint()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpGetFingerprint", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpGetFingerprint_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpGetFingerprint(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpGetFingerprint") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpGetFingerprint_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpGetFingerprint failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::KvpGetLicenceInfo(Rpc_LicenceInfo& _return)
{
  int32_t seqid = send_KvpGetLicenceInfo();
  recv_KvpGetLicenceInfo(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_KvpGetLicenceInfo()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("KvpGetLicenceInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_KvpGetLicenceInfo_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_KvpGetLicenceInfo(Rpc_LicenceInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("KvpGetLicenceInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_KvpGetLicenceInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "KvpGetLicenceInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t kvpServiceConcurrentClient::kvpSetLicence(const std::string& licence)
{
  int32_t seqid = send_kvpSetLicence(licence);
  return recv_kvpSetLicence(seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpSetLicence(const std::string& licence)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpSetLicence", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpSetLicence_pargs args;
  args.licence = &licence;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t kvpServiceConcurrentClient::recv_kvpSetLicence(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpSetLicence") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      kvpService_kvpSetLicence_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpSetLicence failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool kvpServiceConcurrentClient::kvpIsLicenceValid()
{
  int32_t seqid = send_kvpIsLicenceValid();
  return recv_kvpIsLicenceValid(seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpIsLicenceValid()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpIsLicenceValid", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIsLicenceValid_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool kvpServiceConcurrentClient::recv_kvpIsLicenceValid(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpIsLicenceValid") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      kvpService_kvpIsLicenceValid_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIsLicenceValid failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpRegisterSpeakerByStream(Rpc_ModelInfo& _return, const std::vector<int16_t> & utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  int32_t seqid = send_kvpRegisterSpeakerByStream(utt, vp_node, vp_dir, spk_id);
  recv_kvpRegisterSpeakerByStream(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpRegisterSpeakerByStream(const std::vector<int16_t> & utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpRegisterSpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpRegisterSpeakerByStream_pargs args;
  args.utt = &utt;
  args.vp_node = &vp_node;
  args.vp_dir = &vp_dir;
  args.spk_id = &spk_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpRegisterSpeakerByStream(Rpc_ModelInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpRegisterSpeakerByStream") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpRegisterSpeakerByStream_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpRegisterSpeakerByStream failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpIdentifyTopSpeakerByStream(Rpc_TopSpeakerInfo& _return, const std::vector<int16_t> & utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type)
{
  int32_t seqid = send_kvpIdentifyTopSpeakerByStream(utt, vp_node_arr, node_num, top_n, utt_type);
  recv_kvpIdentifyTopSpeakerByStream(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpIdentifyTopSpeakerByStream(const std::vector<int16_t> & utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpIdentifyTopSpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpIdentifyTopSpeakerByStream_pargs args;
  args.utt = &utt;
  args.vp_node_arr = &vp_node_arr;
  args.node_num = &node_num;
  args.top_n = &top_n;
  args.utt_type = &utt_type;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpIdentifyTopSpeakerByStream(Rpc_TopSpeakerInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpIdentifyTopSpeakerByStream") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpIdentifyTopSpeakerByStream_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpIdentifyTopSpeakerByStream failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpVerifySpeakerByStream(Rpc_ScoreInfo& _return, const std::vector<int16_t> & utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type)
{
  int32_t seqid = send_kvpVerifySpeakerByStream(utt, spk_id, vp_node, utt_type);
  recv_kvpVerifySpeakerByStream(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpVerifySpeakerByStream(const std::vector<int16_t> & utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpVerifySpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpVerifySpeakerByStream_pargs args;
  args.utt = &utt;
  args.spk_id = &spk_id;
  args.vp_node = &vp_node;
  args.utt_type = &utt_type;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpVerifySpeakerByStream(Rpc_ScoreInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpVerifySpeakerByStream") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpVerifySpeakerByStream_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpVerifySpeakerByStream failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpTempVerifySpeakerByStream(Rpc_ScoreInfo& _return, const std::vector<int16_t> & utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::vector<int16_t> & utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  int32_t seqid = send_kvpTempVerifySpeakerByStream(utt1, sp_chan1, utt_type1, utt2, sp_chan2, utt_type2);
  recv_kvpTempVerifySpeakerByStream(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpTempVerifySpeakerByStream(const std::vector<int16_t> & utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::vector<int16_t> & utt2, const int32_t sp_chan2, const int32_t utt_type2)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpTempVerifySpeakerByStream", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpTempVerifySpeakerByStream_pargs args;
  args.utt1 = &utt1;
  args.sp_chan1 = &sp_chan1;
  args.utt_type1 = &utt_type1;
  args.utt2 = &utt2;
  args.sp_chan2 = &sp_chan2;
  args.utt_type2 = &utt_type2;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpTempVerifySpeakerByStream(Rpc_ScoreInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpTempVerifySpeakerByStream") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpTempVerifySpeakerByStream_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpTempVerifySpeakerByStream failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void kvpServiceConcurrentClient::kvpNodeGetList(std::vector<std::string> & _return, const std::string& vp_node)
{
  int32_t seqid = send_kvpNodeGetList(vp_node);
  recv_kvpNodeGetList(_return, seqid);
}

int32_t kvpServiceConcurrentClient::send_kvpNodeGetList(const std::string& vp_node)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("kvpNodeGetList", ::apache::thrift::protocol::T_CALL, cseqid);

  kvpService_kvpNodeGetList_pargs args;
  args.vp_node = &vp_node;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void kvpServiceConcurrentClient::recv_kvpNodeGetList(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("kvpNodeGetList") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      kvpService_kvpNodeGetList_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "kvpNodeGetList failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}



