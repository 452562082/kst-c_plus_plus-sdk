// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "kvpService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class kvpServiceHandler : virtual public kvpServiceIf {
 public:
  kvpServiceHandler() {
    // Your initialization goes here
  }

  void kvpPing(std::string& _return) {
    // Your implementation goes here
    printf("kvpPing\n");
  }

  /**
   * 解析语音文件信息。
   * 
   * @param [in] wavpath 语音文件路径。
   * 
   * @return Rpc_UttInfo 返回语音信息。
   * 
   * @param wavpath
   */
  void kvpGetUttInfo(Rpc_UttInfo& _return, const std::string& wavpath) {
    // Your implementation goes here
    printf("kvpGetUttInfo\n");
  }

  /**
   * 将某说话人ID从某个库节点中删除。
   * 
   * @param [in] vp_node 库节点名称。
   * @param [in] vp_dir 库节点本地路径。
   * @param [in] spk_id 说话人ID。
   * 
   * @return KVP_CODE
   * 
   * @param vp_node
   * @param vp_dir
   * @param spk_id
   */
  int32_t kvpModelRemoveBySpkid(const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id) {
    // Your implementation goes here
    printf("kvpModelRemoveBySpkid\n");
  }

  /**
   * 注册说话人。
   * 
   * @param [in] utt 语音路径。
   * @param [in] vp_node 说话人待注册库节点名称。
   * @param [in] vp_dir 声纹库路径。(--------该参数被废弃--------)
   * @param [in] spk_id 说话人ID。
   * @param [in] sp_chan 指定处理声道。
   * 
   * @return Rpc_ModelInfo 说话人模型信息。
   * 
   * @param utt
   * @param vp_node
   * @param vp_dir
   * @param spk_id
   * @param sp_chan
   */
  void kvpRegisterSpeakerByFile(Rpc_ModelInfo& _return, const std::string& utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id, const int32_t sp_chan) {
    // Your implementation goes here
    printf("kvpRegisterSpeakerByFile\n");
  }

  /**
   * 1:1验证。
   * 
   * @param [in] utt 语音路径。
   * @param [in] spk_id 说话人ID。
   * @param [in] vp_node 说话人所在库节点名称。
   * @param [in] utt_type 语音场景类型。
   * @param [in] sp_chan 指定处理声道。
   * 
   * @return Rpc_ScoreInfo 1:1验证信息。
   * 
   * @param utt
   * @param spk_id
   * @param vp_node
   * @param utt_type
   * @param sp_chan
   */
  void kvpVerifySpeakerByFile(Rpc_ScoreInfo& _return, const std::string& utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type, const int32_t sp_chan) {
    // Your implementation goes here
    printf("kvpVerifySpeakerByFile\n");
  }

  /**
   * 1:1验证(给定2段语音进行比较)。
   * 
   * @param [in] utt1 第1段语音路径。
   * @oaram [in] sp_chan1 指定第1段语音声道。
   * @param [in] utt_type1 指定第1段语音场景类型。
   * @param [in] utt2  第2段语音路径。
   * @oaram [in] sp_chan2 指定第2段语音声道。
   * @param [in] utt_type2 指定第2段语音场景类型。
   * 
   * @return Rpc_ScoreInfo 验证得分信息
   * 
   * @param utt1
   * @param sp_chan1
   * @param utt_type1
   * @param utt2
   * @param sp_chan2
   * @param utt_type2
   */
  void kvpTempVerifySpeakerByFile(Rpc_ScoreInfo& _return, const std::string& utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::string& utt2, const int32_t sp_chan2, const int32_t utt_type2) {
    // Your implementation goes here
    printf("kvpTempVerifySpeakerByFile\n");
  }

  /**
   * 说话人辨认。
   * 
   * @param [in] utt 语音文件路径。
   * @param [in] node_list 库节点列表。
   *  @param [in] node_num 库节点数目。
   * @param [in] top_n Top n数目。
   * @param [in] utt_type 语音场景类型。
   * @param [in] sp_chan 指定处理声道，0：左声道，1：右声道。
   * 
   * @return Rpc_TopSpeakerInfo Top n得分信息
   * 
   * @param utt
   * @param vp_node_arr
   * @param node_num
   * @param top_n
   * @param utt_type
   * @param sp_chan
   */
  void kvpIdentifyTopSpeakerByFile(Rpc_TopSpeakerInfo& _return, const std::string& utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type, const int32_t sp_chan) {
    // Your implementation goes here
    printf("kvpIdentifyTopSpeakerByFile\n");
  }

  /**
   * 将说话人模型以文件的形式加载到内存某库节点中。
   * 
   * @param [in] vp_node 库节点名称。
   * @param [in] iv_file 说话人模型文件路径。
   * 
   * @return KVP_CODE
   * 
   * 
   * @param vp_node
   * @param iv_file
   */
  int32_t kvpIvectorLoadByFile(const std::string& vp_node, const std::string& iv_file) {
    // Your implementation goes here
    printf("kvpIvectorLoadByFile\n");
  }

  /**
   * 向总库中插入某个库节点。
   * 
   * @param vp_node 库节点名称。
   * 
   * @return KVP_CODE
   * 
   * @param vp_node
   */
  int32_t kvpInsertNode(const std::string& vp_node) {
    // Your implementation goes here
    printf("kvpInsertNode\n");
  }

  /**
   * 从总库中删除某个库节点。
   * 
   * @param vp_node 库节点名称。
   * 
   * @return KVP_CODE
   * 
   * @param vp_node
   */
  int32_t kvpDeleteNode(const std::string& vp_node) {
    // Your implementation goes here
    printf("kvpDeleteNode\n");
  }

  /**
   * 将说话人模型从一个库移到另一个库。
   * 
   * @param spk_id 说话人ID。
   * @param origin 原始库。
   * @param target 目标库。
   * 
   * @return KVP_CODE
   * 
   * @param spk_id
   * @param origin
   * @param target
   */
  int32_t kvpMoveNode(const std::string& spk_id, const std::string& origin, const std::string& target) {
    // Your implementation goes here
    printf("kvpMoveNode\n");
  }

  /**
   * 获取机器指纹。
   * 
   * @return 机器人指纹字符串。
   */
  void kvpGetFingerprint(std::string& _return) {
    // Your implementation goes here
    printf("kvpGetFingerprint\n");
  }

  /**
   * 获取授权信息。
   * 
   * @return Rpc_LicenceInfo 授权信息。
   */
  void KvpGetLicenceInfo(Rpc_LicenceInfo& _return) {
    // Your implementation goes here
    printf("KvpGetLicenceInfo\n");
  }

  /**
   * 如果已经初始化成功，则直接返回KVP_CODE_SUCCEED，否则进行初始化。
   * 
   *  @param licence 授权字符串。
   *  
   *  @return KVP_CODE
   * 
   * @param licence
   */
  int32_t kvpSetLicence(const std::string& licence) {
    // Your implementation goes here
    printf("kvpSetLicence\n");
  }

  /**
   * 判断Licence是否有效。
   * 
   * 	@return 授权标志。
   */
  bool kvpIsLicenceValid() {
    // Your implementation goes here
    printf("kvpIsLicenceValid\n");
  }

  /**
   * 注册说话人（二进制流格式）。
   * 
   * @param [in] utt 语音路径。
   * @param [in] vp_node 说话人待注册库节点名称。
   * @param [in] vp_dir 声纹库路径。(--------该参数被废弃--------)
   * @param [in] spk_id 说话人ID。
   * 
   * @return Rpc_ModelInfo 说话人模型信息。
   * 
   * @param utt
   * @param vp_node
   * @param vp_dir
   * @param spk_id
   */
  void kvpRegisterSpeakerByStream(Rpc_ModelInfo& _return, const std::vector<int16_t> & utt, const std::string& vp_node, const std::string& vp_dir, const std::string& spk_id) {
    // Your implementation goes here
    printf("kvpRegisterSpeakerByStream\n");
  }

  /**
   * 说话人辨认（二进制流格式）。
   * 
   * @param [in] utt 语音流。
   * @param [in] node_list 库节点列表。
   *  @param [in] node_num 库节点数目。
   * @param [in] top_n Top n数目。
   * @param [in] utt_type 语音场景类型。
   * 
   * @return Rpc_TopSpeakerInfo Top n得分信息
   * 
   * @param utt
   * @param vp_node_arr
   * @param node_num
   * @param top_n
   * @param utt_type
   */
  void kvpIdentifyTopSpeakerByStream(Rpc_TopSpeakerInfo& _return, const std::vector<int16_t> & utt, const std::vector<std::string> & vp_node_arr, const int32_t node_num, const int32_t top_n, const int32_t utt_type) {
    // Your implementation goes here
    printf("kvpIdentifyTopSpeakerByStream\n");
  }

  /**
   * 说话人确认（二进制流格式）。
   * 
   * @param [in] utt 语音流。
   *  @param [in] spk_id 说话人ID。
   * @param [in] vp_node 库节点。
   * @param [in] utt_type 语音场景类型。
   * 
   * @return Rpc_ScoreInfo 得分信息
   * 
   * @param utt
   * @param spk_id
   * @param vp_node
   * @param utt_type
   */
  void kvpVerifySpeakerByStream(Rpc_ScoreInfo& _return, const std::vector<int16_t> & utt, const std::string& spk_id, const std::string& vp_node, const int32_t utt_type) {
    // Your implementation goes here
    printf("kvpVerifySpeakerByStream\n");
  }

  /**
   * 1:1验证(给定2段语音进行比较，二进制流格式)。
   * 
   * @param [in] utt1 第1段语音流。
   * @oaram [in] sp_chan1 指定第1段语音声道。
   * @param [in] utt_type1 指定第1段语音场景类型。
   * @param [in] utt2  第2段语音流。
   * @oaram [in] sp_chan2 指定第2段语音声道。
   * @param [in] utt_type2 指定第2段语音场景类型。
   * 
   * @return Rpc_ScoreInfo 验证得分信息
   * 
   * @param utt1
   * @param sp_chan1
   * @param utt_type1
   * @param utt2
   * @param sp_chan2
   * @param utt_type2
   */
  void kvpTempVerifySpeakerByStream(Rpc_ScoreInfo& _return, const std::vector<int16_t> & utt1, const int32_t sp_chan1, const int32_t utt_type1, const std::vector<int16_t> & utt2, const int32_t sp_chan2, const int32_t utt_type2) {
    // Your implementation goes here
    printf("kvpTempVerifySpeakerByStream\n");
  }

  /**
   * 获取某节点说话人ID列表。
   * 
   * @param [in] vp_node 节点名称。
   * 
   * @return 说话人ID列表
   * 
   * @param vp_node
   */
  void kvpNodeGetList(std::vector<std::string> & _return, const std::string& vp_node) {
    // Your implementation goes here
    printf("kvpNodeGetList\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<kvpServiceHandler> handler(new kvpServiceHandler());
  shared_ptr<TProcessor> processor(new kvpServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

